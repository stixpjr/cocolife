Conway's Game of Life for the Tandy Color Computer (CoCo)

This is a m6809 assmebly implementation of Conway's Game of Life[1] for the
Tandy Color Computer. I've written several implementations of this cellular
automaton, even one for a Pebble watch. All of these went through a
laborious loop for each and every pixel, which is fine on a reasonably
powerful CPU, but terribly slow on a 895kHz m6809. I then found, by accident,
a diagram[2] describing a way of using lookup tables to determine the next
iteration one full byte at a time, and set out to implement code based on that
diagram. This is the result.

Note: I also found a 6502 implementation[3], but haven't studied it closely.

There are 4 separate binaries, for different graphics modes (resolutions).
Obviously, given the algorithm, this only works with 1-bit per pixel modes:
- lifeg6r: 256x192, runs at about 0.286Hz on a real CoCo 1.
- lifeg2r: 128x96, runs at about 1.15Hz on a real CoCo 1.
- lifeg1r: 128x64, runs at about 1.7Hz on a real CoCo 1, but looks weird with
  non-square pixels.
- lif64x32: 64x32, runs at something like 5.3Hz on a real CoCo 1. Uses a CPYBTS
  routine to copy the internal bitmap to the default semigraphics-4 mode
  screen, hence doesn't achieve the theoretical 6.8Hz based on the above
  numbers.

That puts the code at about 64 cycles per pixel; definitely not achievable by
pixel-by-pixel code. Could it be made faster? Almost definitely.

Each implements a "toroidal" grid, with left-right and top-bottom wrapping.
Initial map is generated by a random fill using a fast 8-bit pseudorandom
number generator[4]. If the code detects a static or subtly altering pattern,
it will automatically reset with a random fill. The keyboard is polled at the
end of each iteration, and the Break key exits.

7x256 byte lookup tables are used in all, 6 referenced by the diagram, and an
additional "POPCNT" one to count set pixels to determine changed pixel deltas.
Originally, I generated these tables in BASIC which wrote files to include
into the assembly, but then later switched to generating these in assembly
directly on program start.

The code may be assembled with lwasm[5], but also cleanly assembles with
EDTASM (with minor translations) - meeting one of my original goals. The
included Makefile should create a disk image file containing EDTASM, all
assembly source files, and the 3 BIN programs, assuming lwasm from lwtools and
imgtool from Mame are installed. A short Perl script is used to add/remove
line numbers, minor translations, and change line endings for ease of editing
on Unix-like OSes.

As a comparison, existing simulators in colorcomputerarchive.com:
- Game of Life by Jim Gerrie[6] is written in BASIC, renders on a SG-4 grid of
  64x32, minus one line of text, and with `POKE 65495,0` (but not
  `POKE 65497,0`), each frame takes about 1.5 minutes...
- Game of Life by Spectral Associates[7] is actually very fast! On a 64x64 grid,
  it does about 5Hz! Shame it doesn't do full toroidal wraparound, though.
  Reading the code, it is remarkably short; it uses a clever algorithm making
  use of the 2 bits per pixel mode to efficiently do 4 pixels at a time.
- I didn't look into the MC-10 implementations.

Refs:
[1]: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life
[2]: http://forum.6502.org/download/file.php?id=4546&sid=ec4dacc4ec2e39ca6630efd45d391347&mode=view
[3]: https://github.com/hoglet67/6502Life/blob/master/src/life88_life.asm
[4]: https://www.stix.id.au/wiki/Fast_8-bit_pseudorandom_number_generator
[5]: http://www.lwtools.ca/
[6]: https://colorcomputerarchive.com/repo/Disks/Games/Game%20of%20Life%20%28Jim%20Gerrie%29.zip
[7]: https://colorcomputerarchive.com/repo/Disks/Games/Game%20of%20Life%20%28Spectral%20Associates%29.zip
